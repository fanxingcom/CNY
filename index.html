<!DOCTYPE html>
<html>
<head>
    <title>å¢å¼ºç‰ˆæ‰«é›·</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #ff4d4d; /* çº¢è‰²èƒŒæ™¯ */
            font-family: Arial, sans-serif;
        }

        #header {
            display: flex;
            gap: 20px;
            margin: 15px 0;
        }

        .counter {
            padding: 8px 15px;
            background: #333;
            color: white;
            border-radius: 5px;
            font-weight: bold;
        }

        #game {
            display: grid;
            grid-template-columns: repeat(10, 35px); /* åˆ›å»º10åˆ—çš„ç½‘æ ¼ */
            gap: 2px; /* å•å…ƒæ ¼ä¹‹é—´çš„é—´éš™ */
            background: #f7f3d0; /* æµ…é»„è‰²èƒŒæ™¯ */
            padding: 3px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 2px solid #8c0404; /* æ£‹ç›˜è¾¹æ¡†é¢œè‰² */
        }

        .cell {
            width: 35px;
            height: 35px;
            background: #ffe9b8; /* å•å…ƒæ ¼èƒŒæ™¯é¢œè‰² */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.1s;
            position: relative;
            font-size: 18px;
            border: 1px solid #8c0404; /* æ£‹ç›˜ç»çº¬çº¿é¢œè‰² */
        }

        .cell:hover {
            filter: brightness(1.1); /* é¼ æ ‡æ‚¬åœæ•ˆæœ */
        }

        .revealed {
            background: #ffcc00; /* è¢«æ­ç¤ºçš„å•å…ƒæ ¼èƒŒæ™¯é¢œè‰² */
        }

        .revealed span {
            position: absolute;
        }

        .mine {
            background: #a8a192 !important; /* åœ°é›·å•å…ƒæ ¼èƒŒæ™¯é¢œè‰² */
        }

        .mine::after {
            content: "ğŸ˜”"; /* åœ°é›·å•å…ƒæ ¼æ˜¾ç¤ºçš„è¡¨æƒ…ç¬¦å· */
            font-size: 20px;
            position: absolute;
        }

        .flag::after {
            content: "ğŸ"; /* æ ‡è®°æ——å¸œçš„è¡¨æƒ…ç¬¦å· */
            position: absolute;
            font-size: 20px;
            top: 2px;
            left: 4px;
        }

        .number {
            color: red; /* æ•°å­—é¢œè‰² */
            font-size: 18px;
        }

        #restart {
            margin-top: 20px;
            padding: 10px 25px;
            background: #4CAF50; /* æŒ‰é’®èƒŒæ™¯é¢œè‰² */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }
    </style>
</head>
<body>
    <h2>ğŸŒŸè¾›å…‰ç¥ç¦æ‚¨æ–°æ˜¥å¿«ä¹ğŸğŸŒŸ</h2>
    <h2>ğŸŒŸæ ‡è®°ä¸å¼€å¿ƒè®©æˆ‘ä»¬å¿˜è®°å®ƒä»¬ğŸŒŸ</h2>
    <div id="header">
        <div class="counter">å‰©ä½™: <span id="flags-left">15</span></div> <!-- æ˜¾ç¤ºå‰©ä½™æ——å¸œ -->
        <div class="counter">åœ°é›·: 8</div> <!-- æ˜¾ç¤ºåœ°é›·æ€»æ•° -->
    </div>
    <div id="game"></div> <!-- æ¸¸æˆæ£‹ç›˜ -->
    <button id="restart">å¼€å§‹æ–°å¹´</button> <!-- é‡å¯æ¸¸æˆæŒ‰é’® -->

    <script>
        const SIZE = 10;    // æ£‹ç›˜å¤§å°
        const MINES = 6;   // åœ°é›·æ€»æ•°
        let board = [];
        let gameOver = false;
        let flagsLeft = MINES;

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            gameOver = false;
            flagsLeft = MINES;
            updateFlagCounter();
            
            // åˆ›å»ºæ£‹ç›˜æ•°æ®ç»“æ„
            board = Array(SIZE).fill().map(() => 
                Array(SIZE).fill().map(() => ({
                    isMine: false, // æ˜¯å¦æ˜¯åœ°é›·
                    revealed: false, // æ˜¯å¦å·²è¢«æ­ç¤º
                    flagged: false, // æ˜¯å¦è¢«æ ‡è®°æ——å¸œ
                    neighborMines: 0 // å‘¨å›´åœ°é›·æ•°é‡
                }))
            );

            // å¸ƒç½®åœ°é›·
            let minesPlaced = 0;
            while (minesPlaced < MINES) {
                const x = Math.floor(Math.random() * SIZE);
                const y = Math.floor(Math.random() * SIZE);
                if (!board[x][y].isMine) {
                    board[x][y].isMine = true;
                    minesPlaced++;
                }
            }

            // è®¡ç®—ç›¸é‚»åœ°é›·æ•°
            calculateNumbers();
            renderBoard();
        }

        // è®¡ç®—æ•°å­—
        function calculateNumbers() {
            for (let x = 0; x < SIZE; x++) {
                for (let y = 0; y < SIZE; y++) {
                    if (!board[x][y].isMine) {
                        board[x][y].neighborMines = countNeighborMines(x, y);
                    }
                }
            }
        }

        // è®¡ç®—å‘¨å›´åœ°é›·æ•°
        function countNeighborMines(x, y) {
            let count = 0;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE) {
                        if (board[nx][ny].isMine) count++;
                    }
                }
            }
            return count;
        }

        // æ¸²æŸ“æ£‹ç›˜
        function renderBoard() {
            const game = document.getElementById('game');
            game.innerHTML = '';
            
            board.forEach((row, x) => row.forEach((cell, y) => {
                const element = document.createElement('div');
                element.className = 'cell';
                
                if (cell.revealed) {
                    element.classList.add('revealed');
                    if (cell.isMine) {
                        element.classList.add('mine');
                    } else {
                        if (cell.neighborMines > 0) {
                            element.textContent = cell.neighborMines;
                            element.classList.add('number');
                        } else {
                            const emoji = document.createElement('span');
                            emoji.textContent = 'ğŸ§§';
                            element.appendChild(emoji);
                        }
                    }
                }
                
                if (cell.flagged) element.classList.add('flag');
                
                element.addEventListener('click', () => handleLeftClick(x, y));
                element.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    handleRightClick(x, y);
                });
                
                game.appendChild(element);
            }));
        }

        // å·¦é”®ç‚¹å‡»
        function handleLeftClick(x, y) {
            if (gameOver || board[x][y].flagged) return;
            
            if (board[x][y].isMine) {
                gameOver = true;
                revealAll();
                showMessage('å†æ¥ä¸€æ¬¡å»æ‰ä¸å¼€å¿ƒğŸ¤¯');
                return;
            }
            
            reveal(x, y);
            checkWin();
        }

        // å³é”®ç‚¹å‡»
        function handleRightClick(x, y) {
            if (gameOver || board[x][y].revealed) return;
            
            if (!board[x][y].flagged && flagsLeft <= 0) return;
            
            board[x][y].flagged = !board[x][y].flagged;
            flagsLeft += board[x][y].flagged ? -1 : 1;
            updateFlagCounter();
            renderBoard();
        }

        // é€’å½’æ­ç¤ºå•å…ƒæ ¼
        function reveal(x, y) {
            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return;
            if (board[x][y].revealed || board[x][y].flagged) return;
            
            board[x][y].revealed = true;
            
            if (board[x][y].neighborMines === 0) {
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        reveal(x + dx, y + dy);
                    }
                }
            }
            
            renderBoard();
        }

        // æ˜¾ç¤ºæ‰€æœ‰åœ°é›·
        function revealAll() {
            board.forEach(row => row.forEach(cell => cell.revealed = true));
            renderBoard();
        }

        // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
        function checkWin() {
            let allSafeRevealed = true;
            let allMinesFlagged = true;
            
            board.forEach(row => row.forEach(cell => {
                if (!cell.isMine && !cell.revealed) allSafeRevealed = false;
                if (cell.isMine && !cell.flagged) allMinesFlagged = false;
            }));
            
            if (allSafeRevealed || allMinesFlagged) {
                gameOver = true;
                showMessage('æ­å–œè·èƒœï¼ğŸ‰è›‡å¹´å¿«ä¹ğŸ');
            }
        }

        // æ›´æ–°æ——å¸œè®¡æ•°å™¨
        function updateFlagCounter() {
            document.getElementById('flags-left').textContent = flagsLeft;
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(msg) {
            setTimeout(() => alert(msg), 10);
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        document.getElementById('restart').addEventListener('click', initGame);
        initGame();
    </script>
</body>
</html>
